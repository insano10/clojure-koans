- instead of a function call foo(arg1, arg2), a lisp writes it as (foo arg1 arg2) with the first argument the function to be called followed by the arguments
- as well as strings there are :keywords and 'symbols
- there is hard (=) and loose (==) equality
- \b is the char b (use backslash)
- [1 2 3] is a vector, (1 2 3) is a list. Use a vector when accessing via index and a list when using as a sequence
- #{1 2 3} is a set. You can create them from other collections using (set '(123))
- {:a 1 :b 2} is a map
- declare a named function using (defn [param1 param2] ())
- declare an anonymous function using fn or #() (access parameters with %1 %2 etc.)


- you can use transient data structures to build up collections, then turn them back into persistents for use
  this is much faster than using persistents (https://clojure.org/reference/transients)
  use functions suffixed with ! on transient data structures

functions:

str - creates a string from 0 or more symbols
get - index into something (e.g. string / list)
count - count elements in something
subs - substring
string/split-lines - split a string on \n
char? - is the argument a char
string? - is the argument a string
blank? - is a string empty or nil
subvec - get a slice from a vector inclusive of lower bound, exclusive of upper bound
assoc/dissoc - add/remove values from a map
merge - combine 2 collections

recur - perform tail recursion and jump back to the outer call site (fn or loop) with the specified args